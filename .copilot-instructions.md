# Frontend Development - Copilot Instructions

## Next.js Frontend Development Guidelines

**Location:** This file provides specific guidance for frontend development in the `frontend/` directory.

**Framework:** Next.js 15+ with App Router, React 18+, TypeScript
**Data Fetching:** TanStack Query (React Query) for server state management
**State Management:** Zustand stores for client state (auth, UI, preferences)
**Validation:** Zod for runtime type validation and API contract verification
**Styling:** Tailwind CSS + shadcn/ui component library
**Deployment:** Vercel with global CDN and edge caching
**PWA:** Progressive Web App with offline capabilities

## Azure DevOps Frontend Integration

### Repository: dadisi_frontend
- **URL:** https://dev.azure.com/pascalmuchiri/dadisi_app/_git/dadisi_frontend
- **Branch Strategy:** GitHub Flow (main branch, feature branches)
- **Pipeline:** Separate frontend deployment pipeline to Vercel

### Frontend Work Items
**Common Frontend Work Item Types:**
- **Feature:** UI components, pages, user flows
- **User Story:** Frontend functionality (e.g., "As a member, I want to RSVP to events")
- **Bug:** UI issues, responsive design problems, PWA failures
- **Task:** Component refactoring, performance optimization, accessibility improvements

**Frontend-Specific Acceptance Criteria:**
- Responsive design works on mobile, tablet, desktop
- PWA installs and works offline
- API integration handles loading and error states
- Accessibility meets WCAG 2.1 AA standards
- Performance meets Core Web Vitals requirements

### Azure DevOps PowerShell Scripts
The project includes PowerShell scripts in the `Docs/` directory for managing Azure DevOps work items. These scripts integrate with the Azure CLI and can be used for bulk operations, state management, and hierarchy maintenance.

#### Available Scripts

1. **UpdateWorkItemState.ps1**
   - **Purpose:** Updates the state of one or more Azure DevOps work items
   - **Usage:** `.\UpdateWorkItemState.ps1 -WorkItemIds 123,124 -NewState "Active" -Comment "Ready for development"`
   - **Parameters:**
     - `WorkItemIds`: Array of work item IDs (required)
     - `NewState`: New state (New, Active, Resolved, Closed, etc.) (required)
     - `Comment`: Optional comment for the state change
     - `Project`: Azure DevOps project name (defaults to 'dadisi_app')
     - `Force`: Skip confirmation prompt
   - **Requirements:** Azure CLI with Azure DevOps extension

2. **CheckWorkItems.ps1**
   - **Purpose:** Displays detailed information about a specific work item including hierarchy
   - **Usage:** `.\CheckWorkItems.ps1 123`
   - **Output:** Work item details, parent-child relationships, and full hierarchy
   - **Requirements:** Azure CLI with Azure DevOps extension

3. **CheckAllWorkItems.ps1**
   - **Purpose:** Lists all work items in the Azure DevOps project
   - **Usage:** `.\CheckAllWorkItems.ps1`
   - **Output:** Summary of all work items with ID, title, type, and state
   - **Requirements:** Azure CLI with Azure DevOps extension

4. **create_ado_workitems_v2.ps1**
   - **Purpose:** Bulk creates work items from CSV files with duplicate prevention and parent-child linking
   - **Usage:** `.\create_ado_workitems_v2.ps1 -pat "your-pat-token"`
   - **Features:**
     - Processes CSV files from `Docs/workitems/` directory
     - Handles duplicates based on Key, Title, and Type
     - Establishes parent-child relationships in two passes
     - Logs all operations to `created_work_items_log.csv`
   - **CSV Format:** Requires columns like Key, Title, WorkItemType, Parent, Description, etc.
   - **Requirements:** Azure CLI, Personal Access Token (PAT) with work item permissions

5. **create_ado_workitems.ps1**
   - **Purpose:** Earlier version of bulk work item creation script
   - **Usage:** Similar to v2 but with slightly different duplicate handling
   - **Note:** Use v2 for new operations; this is maintained for reference

6. **AddParentLinkRelation.ps1**
   - **Purpose:** Establishes parent-child relationships between existing work items
   - **Usage:** `.\AddParentLinkRelation.ps1 -pat "your-pat-token"`
   - **Features:** Uses Azure DevOps REST API for reliable linking
   - **Requirements:** Azure CLI, Personal Access Token (PAT)

#### Script Integration with Development Workflow
- **Work Item Creation:** Use `create_ado_workitems_v2.ps1` for bulk importing work items from planning documents
- **State Management:** Use `UpdateWorkItemState.ps1` for transitioning work items through development stages
- **Hierarchy Management:** Use `AddParentLinkRelation.ps1` for establishing or fixing parent-child relationships
- **Monitoring:** Use `CheckWorkItems.ps1` and `CheckAllWorkItems.ps1` for tracking work item status and hierarchy

#### Requirements and Setup
- **Azure CLI:** Must be installed and authenticated (`az login`)
- **Azure DevOps Extension:** Install with `az extension add --name azure-devops`
- **Personal Access Token (PAT):** Required for scripts that modify work items
  - Create in Azure DevOps: User Settings → Personal Access Tokens
  - Scopes: Work Items (read, write, manage)
- **Project Configuration:** Scripts default to 'dadisi_app' project but can be parameterized

#### Troubleshooting Script Issues
- **Authentication Errors:** Verify PAT token and Azure CLI login status
- **Extension Issues:** Reinstall Azure DevOps extension if commands fail
- **Permission Errors:** Ensure PAT has appropriate scopes for work item operations
- **CSV Format Errors:** Validate CSV structure matches expected columns
- **Hierarchy Issues:** Use `CheckWorkItems.ps1` to verify parent-child relationships before linking

### MCP Server Integration
The project is configured with several Model Context Protocol (MCP) servers that provide additional tools and resources for development. These servers enhance Copilot's capabilities for specific tasks.

#### Available MCP Servers

1. **GitHub MCP Server (@github/github-mcp-server)**
   - **Purpose:** GitHub repository management, issues, pull requests, and code search
   - **Usage:** Use for GitHub-related operations like creating issues, reviewing PRs, or searching code across repositories
   - **Integration:** Automatically available for GitHub operations in the project

2. **Supabase MCP Server (supabase-mcp-server)**
   - **Purpose:** Supabase database operations, schema management, and query execution
   - **Usage:** Use for database-related tasks, migrations, or querying Supabase projects
   - **Integration:** Useful for backend database development and testing
   - **Note:** Configured with access token for authenticated operations

3. **Sentry MCP Server (getsentry/sentry-mcp)**
   - **Purpose:** Error tracking, monitoring, and performance analysis
   - **Usage:** Use for debugging, error investigation, and performance monitoring
   - **Integration:** Helpful for troubleshooting backend issues and monitoring production errors

4. **Context7 MCP Server (upstash/context7)**
   - **Purpose:** Documentation search, library information, and code examples
   - **Usage:** Use for looking up documentation, finding libraries, or getting code snippets
   - **Integration:** Useful for research and learning new technologies
   - **Note:** Requires context7_api_key for full functionality

5. **Sequential Thinking MCP Server (sequential-thinking)**
   - **Purpose:** Structured problem-solving and step-by-step reasoning
   - **Usage:** Use for complex problem analysis, planning, and decision-making processes
   - **Integration:** Helpful for breaking down complex features or debugging issues

6. **21st.dev Magic MCP Server (@21st-dev/magic)**
   - **Purpose:** UI component generation, design inspiration, and frontend development
   - **Usage:** Use for creating React components, getting design ideas, or improving UI
   - **Integration:** Particularly useful for frontend development tasks
   - **Commands:** Use /ui, /21, or /21st to trigger component generation

7. **Chrome DevTools MCP Server (chrome-devtools)**
   - **Purpose:** Browser debugging, performance analysis, and DevTools integration
   - **Usage:** Use for inspecting web applications, debugging JavaScript, analyzing network requests, and performance monitoring
   - **Integration:** Particularly useful for frontend debugging, troubleshooting runtime issues, and optimization tasks
   - **Requirements:** Chrome browser must be running with DevTools enabled
   - **Commands:** Use /devtools or /chrome to trigger debugging assistance
 

#### Using MCP Servers in Development
- **Automatic Integration:** MCP servers are automatically available based on context and can be triggered by relevant queries
- **Specific Triggers:**
  - For UI components: Mention /ui, /21, or /21st in your queries
  - For documentation: Use Context7 for library or framework research
  - For problem-solving: Invoke sequential thinking for complex analysis
  - For database tasks: Use Supabase MCP for schema or query operations
- **Best Practices:** Be specific in your requests to leverage the appropriate MCP server effectively

#### MCP Configuration
- **Location:** Configured in VS Code's MCP settings (`mcp.json`)
- **Management:** Servers can be enabled/disabled or reconfigured as needed
- **Updates:** Keep MCP servers updated for latest features and security

## Next.js Development Standards

### Project Structure
```
frontend/
├── src/
│   ├── app/                 # App Router pages and layouts
│   ├── components/          # Reusable React components
│   ├── config/              # Site configuration (site.ts)
│   ├── hooks/               # Custom React hooks (useAdminMenu.ts)
│   ├── lib/                 # Utility functions and configurations
│   ├── store/               # Zustand state management stores
│   ├── stores/              # Additional store patterns
│   ├── styles/              # Global styles and Tailwind config
│   └── types/               # TypeScript type definitions
├── public/                  # Static assets
├── components.json          # shadcn/ui configuration
├── vitest.config.ts         # Vitest testing configuration
└── tailwind.config.js       # Tailwind CSS configuration
```

### App Router Structure
```
src/app/
├── layout.tsx              # Root layout with providers
├── page.tsx                # Home page
├── admin/                  # Admin pages
├── blog/                   # Blog pages
├── dashboard/              # User dashboard
├── donations/              # Donation pages
├── events/                 # Event pages
└── membership/             # Membership pages
```

### Component Architecture

#### shadcn/ui Components
- **Location:** `src/components/ui/` (button, card, input, etc.)
- **Customization:** Override default styles in component files
- **Usage:** Import from `@/components/ui/[component-name]`

#### Custom Components
- **Location:** `src/components/` (auth-dialog, events-client, etc.)
- **Naming:** PascalCase for components, kebab-case for files
- **Props:** TypeScript interfaces for all props
- **Styling:** Tailwind CSS classes with responsive design

#### Component Example
```tsx
// src/components/events-client.tsx
interface EventsClientProps {
  events: Event[];
  loading: boolean;
}

export function EventsClient({ events, loading }: EventsClientProps) {
  if (loading) return <div>Loading events...</div>;

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {events.map((event) => (
        <Card key={event.id} className="hover:shadow-lg transition-shadow">
          {/* Event content */}
        </Card>
      ))}
    </div>
  );
}
```

### State Management

#### Zustand Stores (Primary Pattern)
- **Location:** `src/store/` (auth.ts, memberProfile.ts, etc.)
- **Pattern:** Zustand for complex state management with persistence
- **API Integration:** Direct integration with centralized API layers
- **Error Handling:** Centralized error states in stores

#### Zustand Store Pattern
```tsx
// src/store/auth.ts - Authentication store with API integration
import { create } from "zustand"
import { persist } from "zustand/middleware"
import { memberProfileApi, authApi } from "@/lib/api"

interface AuthState {
  token: string | null
  user: User | null
  isLoading: boolean
  error: string | null
  login: (credentials: LoginData) => Promise<void>
  logout: () => Promise<void>
  setToken: (token: string) => Promise<void>
}

export const useAuth = create<AuthState>()(
  persist(
    (set, get) => ({
      token: null,
      user: null,
      isLoading: false,
      error: null,

      login: async (credentials: LoginData) => {
        set({ isLoading: true, error: null })
        try {
          const response = await authApi.login(credentials)
          set({
            token: response.access_token,
            user: response.user,
            isLoading: false
          })

          // Populate related stores
          const memberStore = useMemberProfile.getState()
          if (response.user.member_profile) {
            memberStore.setMemberProfile(response.user.member_profile)
          }
        } catch (error) {
          set({ error: error.message, isLoading: false })
          throw error
        }
      },

      logout: async () => {
        set({ isLoading: true, error: null })
        try {
          await authApi.logout()
        } catch (error) {
          // Silent logout failure
          console.error("Logout API error:", error)
        } finally {
          // Always clear local state
          set({ token: null, user: null, isLoading: false })
        }
      },

      setToken: async (token: string) => {
        set({ token, isLoading: true, error: null })
        try {
          const user = await authApi.getUser()
          set({ user, isLoading: false })
        } catch (error) {
          set({ token: null, user: null, isLoading: false, error: error.message })
          throw error
        }
      },
    }),
    {
      name: "auth-storage",
      partialize: (state) => ({
        token: state.token,
        user: state.user,
      }),
    }
  )
)
```

#### Custom React Hooks
- **Location:** `src/hooks/` (useAdminMenu.ts, etc.)
- **Pattern:** Custom hooks for reusable logic
- **Usage:** Component-specific logic extraction

#### useState for Local Component State
- **When to use:** Simple local state within components
- **Pattern:** `useState` + `useEffect` for component-level data fetching
- **Limitation:** Avoid complex state logic in components

#### State Management Guidelines

**Choose the Right Pattern:**
- **Zustand Store:** Complex state, API integration, cross-component sharing
- **Custom Hook:** Reusable component logic, side effects
- **useState:** Simple local component state only

**Store Organization:**
- Group related state in single stores
- Use persist middleware for auth/user data
- Handle loading/error states consistently
- Populate related stores on auth changes

**Error Handling in Stores:**
```tsx
// Proper error handling pattern
login: async (credentials) => {
  set({ loading: true, error: null })
  try {
    const response = await authApi.login(credentials)
    set({ user: response.user, token: response.token, loading: false })
  } catch (error) {
    const message = error.status === 401 ? "Invalid credentials" : error.message
    set({ error: message, loading: false })
    throw error
  }
}
```

**Store Communication:**
```tsx
// Stores can communicate with each other
login: async (credentials) => {
  const response = await authApi.login(credentials)
  set({ user: response.user, token: response.token })

  // Update related stores
  const memberStore = useMemberProfile.getState()
  if (response.user.member_profile) {
    memberStore.setMemberProfile(response.user.member_profile)
  }
}
```

#### Context Providers vs Stores

**Theme Provider (NextThemes) - Intentional Exception:**
```tsx
// src/components/theme-provider.tsx:1 - Context Provider (not store-based)
import { ThemeProvider } from "next-themes"

// Used in layout.tsx:87 - This is intentional
<ThemeProvider
  attribute="class"
  defaultTheme="system"
  enableSystem
  disableTransitionOnChange
>
  {children}
</ThemeProvider>
```

**Why Theme Uses Context (Not Zustand):**
- Theme is UI styling, not application state
- Needs to be available immediately on app load
- Context provides direct access without store subscriptions
- Follows Next.js ecosystem patterns (next-themes)

**Everything Else Uses Zustand:**
- User authentication & profiles
- API data & loading states
- Form state & validation
- Application preferences
- Cross-component shared state

### Styling Guidelines

#### Tailwind CSS
- **Responsive Design:** Use `sm:`, `md:`, `lg:`, `xl:` prefixes
- **Component Variants:** Hover, focus, active states
- **Custom Colors:** Define in `tailwind.config.js`
- **Spacing:** Use consistent spacing scale

#### shadcn/ui Integration
```tsx
// Example component using shadcn/ui
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

export function EventCard({ event }: { event: Event }) {
  return (
    <Card className="w-full max-w-sm mx-auto">
      <CardHeader>
        <CardTitle>{event.title}</CardTitle>
      </CardHeader>
      <CardContent>
        <p className="text-muted-foreground">{event.description}</p>
        <Button className="w-full mt-4">RSVP Now</Button>
      </CardContent>
    </Card>
  );
}
```

### PWA Implementation

#### Service Worker
- **Caching Strategy:** Cache-first for static assets, network-first for API calls
- **Offline Fallback:** Custom offline page for core routes
- **Background Sync:** For form submissions when offline

#### Manifest Configuration
```json
// public/manifest.json
{
  "name": "Dadisi Community Labs",
  "short_name": "Dadisi",
  "description": "Community platform for events, donations, and memberships",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#000000",
  "icons": [...]
}
```

### API Integration

#### Environment Variables
```env
# Development (.env.local)
NEXT_PUBLIC_API_BASE_URL=http://localhost:8000/api
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Staging (.env.staging)
NEXT_PUBLIC_API_BASE_URL=https://staging-api.dadisilab.com/api
NEXT_PUBLIC_APP_URL=https://staging.dadisilab.com

# Production (.env.production)
NEXT_PUBLIC_API_BASE_URL=https://api.dadisilab.com/api
NEXT_PUBLIC_APP_URL=https://dadisilab.com
```

#### Centralized API Layers

The frontend uses two centralized TypeScript API layers for all backend communication:

- **`src/lib/api.ts`** - Public API layer for user-facing operations
- **`src/lib/api-admin.ts`** - Admin API layer for administrative operations

##### Base API Request Function

```tsx
// src/lib/api.ts - Core API functionality
const baseURL = process.env.NEXT_PUBLIC_API_BASE_URL || "http://localhost:8000"

interface ApiResponse<T> {
  success?: boolean
  data?: T
  message?: string
  error?: string
}

interface ApiRequestOptions extends RequestInit {
  params?: Record<string, string | number | boolean>
}

async function apiRequest<T = any>(
  endpoint: string,
  options: ApiRequestOptions = {}
): Promise<T> {
  const { params, ...requestOptions } = options

  // Build URL with query parameters
  let url = `${baseURL}${endpoint}`
  if (params) {
    const searchParams = new URLSearchParams()
    Object.entries(params).forEach(([key, value]) => {
      searchParams.append(key, String(value))
    })
    url += `?${searchParams.toString()}`
  }

  // Set default headers with authentication
  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    Accept: "application/json",
  }

  // Add Authorization header if token exists
  try {
    if (typeof window !== "undefined") {
      const authStorage = localStorage.getItem("auth-storage")
      if (authStorage) {
        const authState = JSON.parse(authStorage)
        const token = authState.state?.token
        if (token) {
          headers.Authorization = `Bearer ${token}`
        }
      }
    }
  } catch (e) {
    console.error("Failed to read auth token:", e)
  }

  const response = await fetch(url, {
    ...requestOptions,
    headers: { ...headers, ...requestOptions.headers },
  })

  // Handle empty responses
  if (response.status === 204 || response.headers.get("content-length") === "0") {
    if (!response.ok) {
      const error = new Error(`HTTP ${response.status}: ${response.statusText}`)
      ;(error as any).status = response.status
      throw error
    }
    return undefined as T
  }

  const isJson = response.headers.get("content-type")?.includes("application/json")
  let data: any

  try {
    data = isJson ? await response.json() : await response.text()
  } catch (e) {
    data = null
  }

  if (!response.ok) {
    let errorMessage = data?.message || `HTTP ${response.status}: ${response.statusText}`

    if (response.status === 401) {
      errorMessage = "Your session has expired. Please log in again."
    } else if (response.status === 403) {
      errorMessage = "You do not have permission to access this resource."
    }

    const error = new Error(errorMessage) as Error & {
      status?: number
      data?: any
    }
    error.status = response.status
    error.data = data
    throw error
  }

  return data as T
}

// HTTP method helpers
export const api = {
  get: <T = any>(endpoint: string, options?: ApiRequestOptions) =>
    apiRequest<T>(endpoint, { ...options, method: "GET" }),

  post: <T = any>(endpoint: string, body?: any, options?: ApiRequestOptions) =>
    apiRequest<T>(endpoint, {
      ...options,
      method: "POST",
      body: body ? JSON.stringify(body) : undefined,
    }),

  put: <T = any>(endpoint: string, body?: any, options?: ApiRequestOptions) =>
    apiRequest<T>(endpoint, {
      ...options,
      method: "PUT",
      body: body ? JSON.stringify(body) : undefined,
    }),

  patch: <T = any>(endpoint: string, body?: any, options?: ApiRequestOptions) =>
    apiRequest<T>(endpoint, {
      ...options,
      method: "PATCH",
      body: body ? JSON.stringify(body) : undefined,
    }),

  delete: <T = any>(endpoint: string, options?: ApiRequestOptions) =>
    apiRequest<T>(endpoint, { ...options, method: "DELETE" }),
}
```

##### API Module Pattern

Group related endpoints into typed modules:

```tsx
// src/lib/api.ts - Example API modules
export const retentionApi = {
  getAll: (params?: { data_type?: string }) =>
    api.get<ApiResponse<RetentionSetting[]>>(
      "/api/retention-settings",
      { params }
    ),

  getOne: (id: number) =>
    api.get<ApiResponse<RetentionSetting>>(
      `/api/retention-settings/${id}`
    ),

  update: (
    id: number,
    data: { retention_days: number; auto_delete: boolean; description?: string }
  ) =>
    api.put<ApiResponse<{ data: RetentionSetting }>>(
      `/api/retention-settings/${id}`,
      data
    ),

  getSummary: () =>
    api.get<ApiResponse<{ data: Record<string, number> }>>(
      "/api/retention-settings-summary"
    ),
}

export const authApi = {
  signup: (data: any) => api.post("/api/auth/signup", data),
  login: (data: any) =>
    api.post<{
      user: any
      access_token: string
      email_verified: boolean
    }>("/api/auth/login", data),
  logout: () => api.post("/api/auth/logout"),
  getUser: () => api.get<any>("/api/auth/user"),
  sendVerification: () => api.post("/api/auth/send-verification"),
  changePassword: (data: any) => api.post("/api/auth/password/change", data),
  verifyEmail: (data: { code: string }) =>
    api.post<{
      message: string
      token: string
      user: any
    }>("/api/auth/verify-email", data),
}

export const plansApi = {
  getAll: () => api.get<any>("/api/plans"),
}

export const subscriptionsApi = {
  create: (data: { plan_id: number; billing_interval: "monthly" | "yearly" }) =>
    api.post<any>("/api/subscriptions", data),
}

export const memberProfileApi = {
  getMe: () => api.get<MemberProfileResponse>("/api/member-profiles/me"),

  getCounties: () => api.get<CountiesResponse>("/api/counties"),

  update: (id: number, data: Partial<MemberProfile>) =>
    api.put<MemberProfileResponse>(`/api/member-profiles/${id}`, data),
}
```

##### Admin API Layer

```tsx
// src/lib/api-admin.ts - Admin operations
import { api } from "@/lib/api"

export const userApi = {
  list: (params?: { search?: string; role?: string; page?: number }) =>
    api.get<AdminApiResponse<PaginatedResponse<AdminUser>>>("/api/users", {
      params: params as Record<string, string | number | boolean>,
    }),

  get: (id: number) => api.get<AdminApiResponse<AdminUser>>(`/api/users/${id}`),

  update: (id: number, data: { username?: string; email?: string }) =>
    api.put<AdminApiResponse<AdminUser>>(`/api/users/${id}`, data),

  delete: (id: number) =>
    api.delete<AdminApiResponse<{ message: string }>>(`/api/users/${id}`),
}

export const adminApi = {
  users: userApi,
  roles: roleApi,
  permissions: permissionApi,
  retention: retentionApi,
  auditLogs: auditLogApi,
}
```

#### Best Practices for API Integration

##### Always Use Centralized APIs
- **Never use `fetch()` directly** in components or stores
- **Import from centralized layers:** `import { api, memberProfileApi } from "@/lib/api"`
- **For admin operations:** `import { adminApi } from "@/lib/api-admin"`

##### Error Handling Patterns
```tsx
// In stores/components - proper error handling
try {
  const response = await memberProfileApi.getMe()
  // Handle success
} catch (error) {
  if (error.status === 401) {
    // Redirect to login
  } else if (error.status === 403) {
    // Show permission error
  } else {
    // Show generic error
  }
}
```

##### Loading States
```tsx
// In Zustand stores
interface StoreState {
  data: DataType[]
  loading: boolean
  error: string | null
  fetchData: () => Promise<void>
}

export const useDataStore = create<StoreState>((set) => ({
  data: [],
  loading: false,
  error: null,
  fetchData: async () => {
    set({ loading: true, error: null })
    try {
      const response = await api.get<DataType[]>("/api/data")
      set({ data: response, loading: false })
    } catch (error) {
      set({ error: error.message, loading: false })
    }
  },
}))
```

##### Adding New API Endpoints

**For Public APIs (`src/lib/api.ts`):**
```tsx
// Add to existing module or create new one
export const eventsApi = {
  getAll: (params?: { page?: number; search?: string }) =>
    api.get<ApiResponse<Event[]>>("/api/events", { params }),

  getOne: (id: number) => api.get<ApiResponse<Event>>(`/api/events/${id}`),

  create: (data: CreateEventData) =>
    api.post<ApiResponse<Event>>("/api/events", data),

  update: (id: number, data: UpdateEventData) =>
    api.put<ApiResponse<Event>>(`/api/events/${id}`, data),

  delete: (id: number) =>
    api.delete<ApiResponse<{ message: string }>>(`/api/events/${id}`),

  rsvp: (id: number) =>
    api.post<ApiResponse<RSVP>>("/api/events/${id}/rsvp", {}),
}
```

**For Admin APIs (`src/lib/api-admin.ts`):**
```tsx
// Add admin operations
export const eventsAdminApi = {
  list: (params?: AdminListParams) =>
    api.get<AdminApiResponse<PaginatedResponse<AdminEvent>>>("/api/admin/events", {
      params: params as Record<string, string | number | boolean>,
    }),

  update: (id: number, data: AdminEventUpdate) =>
    api.put<AdminApiResponse<AdminEvent>>(`/api/admin/events/${id}`, data),

  bulkDelete: (ids: number[]) =>
    api.post<AdminApiResponse<BulkOperationResult>>("/api/admin/events/bulk/delete", {
      ids,
    }),
}
```

##### Code Organization Guidelines

- **Group related endpoints** into modules (e.g., `userApi`, `eventsApi`)
- **Use consistent naming:** `getAll`, `getOne`, `create`, `update`, `delete`
- **Type all responses** with proper interfaces from `@/types`
- **Handle pagination** consistently with `PaginatedResponse<T>`
- **Document parameters** and return types clearly

##### Usage Examples

**In Components:**
```tsx
// src/components/events-list.tsx
"use client"

import { useEffect, useState } from "react"
import { api } from "@/lib/api"
import { Event } from "@/types"

export function EventsList() {
  const [events, setEvents] = useState<Event[]>([])
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const fetchEvents = async () => {
      try {
        const response = await api.get<Event[]>("/api/events")
        setEvents(response)
      } catch (error) {
        console.error("Failed to fetch events:", error)
      } finally {
        setLoading(false)
      }
    }

    fetchEvents()
  }, [])

  if (loading) return <div>Loading...</div>

  return (
    <div>
      {events.map(event => (
        <div key={event.id}>{event.title}</div>
      ))}
    </div>
  )
}
```

**In Zustand Stores:**
```tsx
// src/store/auth.ts
import { api } from "@/lib/api"

export const useAuth = create<AuthState>((set) => ({
  login: async (credentials: LoginData) => {
    set({ loading: true, error: null })
    try {
      const response = await api.post<{
        user: User
        access_token: string
      }>("/api/auth/login", credentials)

      set({
        user: response.user,
        token: response.access_token,
        loading: false
      })
    } catch (error) {
      set({ error: error.message, loading: false })
      throw error
    }
  },
}))
```

**Admin Operations:**
```tsx
// src/components/admin/user-management.tsx
import { adminApi } from "@/lib/api-admin"

export function UserManagement() {
  const handleDeleteUser = async (userId: number) => {
    try {
      await adminApi.users.delete(userId)
      // Refresh user list
    } catch (error) {
      console.error("Failed to delete user:", error)
    }
  }

  const handleBulkAssignRole = async (userIds: number[], roleName: string) => {
    try {
      await adminApi.users.bulkAssignRole(userIds, roleName)
      // Show success message
    } catch (error) {
      // Handle error
    }
  }
}
```

### TypeScript Integration

#### Type Definitions
```tsx
// src/types/index.d.ts
export interface User {
  id: number;
  name: string;
  email: string;
  profile: MemberProfile;
}

export interface Event {
  id: number;
  title: string;
  description: string;
  starts_at: string;
  ends_at?: string;
  venue?: string;
  is_online: boolean;
  capacity?: number;
  county: County;
  price?: number;
  currency: string;
  status: 'draft' | 'published';
}

export interface County {
  id: number;
  name: string;
  code?: string;
}
```

#### API Response Types
```tsx
// src/types/api.ts
export interface ApiResponse<T> {
  data: T;
  meta?: {
    pagination?: {
      page: number;
      per_page: number;
      total: number;
      last_page: number;
    };
  };
}

export interface ApiError {
  message: string;
  errors?: Record<string, string[]>;
}
```

### Testing Standards

#### Frontend Testing Policy

**Scope:** Next.js + Zustand + Vitest frontend, Laravel backend

**Rules:**

1. **Frontend Unit & Integration Tests (Vitest)**
   - ❌ **DO NOT depend on:** Running Laravel server, database migrations/seeded data, real network calls
   - ✅ **ALWAYS mock:** Backend APIs (`authApi`, `memberProfileApi`, etc.)
   - Tests must be: Deterministic, Fast, Fully isolated from backend state

2. **Use Fixtures, Not Database Seeds**
   - ❌ Backend seeded data must NOT be used directly in frontend tests
   - ✅ Create frontend fixtures that mirror API response shape, not exact DB values
   - Focus on behavioral intent (roles, permissions, flags), not IDs

   ```typescript
   const adminUserFixture = {
     id: 1,
     email: "admin@test.com",
     email_verified_at: "2024-01-01",
     roles: [{ name: "super_admin" }],
     permissions: [],
   };
   ```

3. **Member Profile Handling in Tests**
   - `memberProfileApi.getMe()` must always be mocked in auth-related tests
   - Member profile loading is non-blocking and must not fail auth tests if unavailable

4. **What Seeded Data IS Allowed For**
   - ✅ Laravel-seeded data MAY ONLY be used in E2E tests (Playwright/Cypress)
   - ✅ Full login, authorization, and role-based access flows

5. **Test Layering Model**
   | Test Type | Tool | Backend Dependency |
   |-----------|------|-------------------|
   | Unit | Vitest | ❌ None |
   | Integration (API mocked) | Vitest/MSW | ❌ None |
   | E2E | Playwright | ✅ Laravel + seeds |

6. **Contract Stability**
   - Frontend tests validate API contracts, not database correctness
   - If backend response shapes change, update fixtures—not tests to hit backend
   - **Summary:** Mock APIs, not databases. Share contracts, not seed data. Seeds for E2E only. Frontend tests must run offline.

#### Component Testing with Vitest
```tsx
// Example component test with Vitest
import { describe, it, expect, vi } from 'vitest'
import { render, screen } from '@testing-library/react'
import { EventCard } from '@/components/event-card'

// Mock the API calls
vi.mock('@/lib/api', () => ({
  memberProfileApi: {
    getMe: vi.fn().mockResolvedValue({ data: mockUserProfile })
  }
}))

describe('EventCard', () => {
  const mockEvent = {
    id: 1,
    title: 'Test Event',
    description: 'Test Description',
    starts_at: '2025-01-01T10:00:00Z',
    county: { id: 1, name: 'Nairobi' },
  }

  it('renders event information', () => {
    render(<EventCard event={mockEvent} />)
    expect(screen.getByText('Test Event')).toBeInTheDocument()
    expect(screen.getByText('Test Description')).toBeInTheDocument()
  })
})
```

#### Zustand Store Testing
```tsx
// src/store/auth.test.ts
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { act, renderHook, waitFor } from '@testing-library/react'
import { useAuth } from './auth'

// Mock the API
vi.mock('@/lib/api', () => ({
  authApi: {
    login: vi.fn(),
    logout: vi.fn(),
    getUser: vi.fn()
  },
  memberProfileApi: {
    getMe: vi.fn()
  }
}))

describe('useAuth', () => {
  beforeEach(() => {
    // Reset store state between tests
    const { result } = renderHook(() => useAuth())
    act(() => {
      result.current.logout()
    })
  })

  it('handles successful login', async () => {
    const mockResponse = {
      user: { id: 1, email: 'test@example.com' },
      access_token: 'mock-token'
    }

    const { authApi } = await import('@/lib/api')
    vi.mocked(authApi.login).mockResolvedValue(mockResponse)

    const { result } = renderHook(() => useAuth())

    await act(async () => {
      await result.current.login({ email: 'test@example.com', password: 'password' })
    })

    await waitFor(() => {
      expect(result.current.user).toEqual(mockResponse.user)
      expect(result.current.token).toBe(mockResponse.access_token)
      expect(result.current.isLoading).toBe(false)
    })
  })
})
```

#### E2E Testing
- **Tool:** Playwright
- **Coverage:** Critical user flows (registration, donation, event RSVP)
- **CI Integration:** Run on pull requests
- **Backend Dependency:** ✅ Laravel + seeds allowed for E2E only

### Deployment to Vercel

#### Build Configuration
```json
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    domains: ['api.dadisilab.com', 'staging-api.dadisilab.com'],
  },
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: 'https://api.dadisilab.com/api/:path*',
      },
    ];
  },
};
```

#### Environment Variables in Vercel
- **Development:** Automatic from `.env.local`
- **Staging:** Set in Vercel dashboard for staging environment
- **Production:** Set in Vercel dashboard for production environment

#### PWA Optimization
- **Static Generation:** Use `generateStaticParams` for dynamic routes
- **Image Optimization:** Next.js Image component with proper sizing
- **Font Optimization:** Preload custom fonts
- **Bundle Analysis:** Monitor bundle size in production

### Performance Optimization

#### Core Web Vitals
- **LCP:** Optimize largest contentful paint with image optimization
- **FID:** Minimize JavaScript execution time
- **CLS:** Prevent layout shifts with proper sizing

#### Bundle Optimization
- **Code Splitting:** Dynamic imports for route-based splitting
- **Tree Shaking:** Remove unused code
- **Image Optimization:** Use Next.js Image component
- **Font Loading:** Optimize web font loading

### Accessibility (WCAG 2.1 AA)

#### Implementation Guidelines
- **Semantic HTML:** Use proper heading hierarchy, landmarks
- **Keyboard Navigation:** All interactive elements keyboard accessible
- **Screen Reader Support:** ARIA labels, descriptions
- **Color Contrast:** Minimum 4.5:1 contrast ratio
- **Focus Management:** Visible focus indicators

#### Testing Tools
- **Lighthouse:** Accessibility audit
- **axe-core:** Automated accessibility testing
- **Manual Testing:** Keyboard navigation, screen reader testing

### Responsive Design

#### Breakpoint Strategy
```css
/* Tailwind breakpoints */
sm: 640px   /* Small devices */
md: 768px   /* Medium devices */
lg: 1024px  /* Large devices */
xl: 1280px  /* Extra large devices */
```

#### Mobile-First Approach
- Base styles for mobile
- Progressive enhancement for larger screens
- Touch-friendly interface elements
- Optimized images for different screen densities

### Error Handling

#### API Error Handling
```tsx
// src/components/error-boundary.tsx
'use client';

import { Component, ReactNode } from 'react';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback: ReactNode;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps> {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
}
```

#### Loading States & User Feedback

##### SweetAlert Integration
- **Package:** `sweetalert2` for rich user notifications
- **Usage:** For success messages, confirmations, and complex loading states
- **Location:** Import from `@/lib/sweetalert`

##### Loading State Patterns
```tsx
// SweetAlert for user feedback
import { showInfo } from "@/lib/sweetalert"

// In components
export function DonationsClient() {
  const [loading, setLoading] = useState(false)

  const handleDonate = async () => {
    setLoading(true)
    try {
      // Process donation
      await processDonation(data)

      // Show success with SweetAlert
      await Swal.fire({
        icon: "success",
        title: "Donation Successful",
        text: "Thank you for your generous donation!",
        timer: 2000,
      })
    } catch (error) {
      showInfo("Feature unavailable: system under maintenance.")
    } finally {
      setLoading(false)
    }
  }

  return (
    <Button onClick={handleDonate} disabled={loading}>
      {loading ? "Processing..." : "Donate"}
    </Button>
  )
}
```

##### Confirmation Dialogs
```tsx
// Using SweetAlert for confirmations
const handleDelete = async (item: Item) => {
  const result = await Swal.fire({
    title: "Delete Item",
    text: "Are you sure you want to delete this item?",
    icon: "warning",
    showCancelButton: true,
    confirmButtonColor: "#d33",
    cancelButtonColor: "#3085d6",
  })

  if (result.isConfirmed) {
    await deleteItem(item.id)
    await Swal.fire("Deleted!", "Item has been deleted.", "success")
  }
}
```

##### Loading Spinner Component
```tsx
// src/components/loading-spinner.tsx
export function LoadingSpinner({ size = "default" }: { size?: "sm" | "default" | "lg" }) {
  const sizeClasses = {
    sm: "h-4 w-4",
    default: "h-8 w-8",
    lg: "h-12 w-12"
  }

  return (
    <div className="flex items-center justify-center p-8">
      <div className={`animate-spin rounded-full border-b-2 border-primary ${sizeClasses[size]}`}></div>
    </div>
  )
}
```

### Development Workflow

#### Creating New Features
1. **Work Item:** Create in Azure DevOps with UI/UX requirements
2. **Branch:** Create feature branch (`feature/123-user-dashboard`)
3. **Design:** Create responsive components with shadcn/ui
4. **Implementation:** Connect to backend APIs with proper error handling
5. **Testing:** Component tests and accessibility testing
6. **PWA Testing:** Verify offline functionality and installability
7. **Pull Request:** Submit with screenshots and testing notes
8. **Deployment:** Deploy via frontend pipeline to Vercel

standardize API requests in frontend to use a centralized TypeScript API layer api.ts(public) api-admin.ts(admin) instead of scattered fetch() calls### Centralized API Layer

#### Component Development
1. **Requirements:** Review acceptance criteria from work item
2. **Design:** Follow shadcn/ui patterns and Tailwind conventions
3. **Implementation:** TypeScript with proper prop types
4. **Responsive:** Test on multiple screen sizes
5. **Accessibility:** WCAG 2.1 AA compliance
6. **Performance:** Optimize images and loading states

### Vercel Deployment

#### Automatic Deployments
- **Trigger:** Pushes to main branch
- **Build Logs:** Available in Vercel dashboard
- **Environment Variables:** Configured per environment
- **Domain Management:** Custom domains with SSL

#### Deployment Checklist
- [ ] Environment variables configured
- [ ] Build passes without errors
- [ ] PWA manifest valid
- [ ] Service worker registered
- [ ] API endpoints accessible
- [ ] SSL certificate active

### Troubleshooting

#### Common Frontend Issues
- **Build Errors:** Check TypeScript errors, missing dependencies
- **Runtime Errors:** Check browser console, API connectivity
- **Styling Issues:** Verify Tailwind configuration, component imports
- **PWA Issues:** Check manifest, service worker registration
- **Performance Issues:** Monitor Core Web Vitals, bundle size

#### Vercel-Specific Issues
- **Deployment Failures:** Check build logs, environment variables
- **Domain Issues:** Verify DNS configuration, SSL certificates
- **Environment Variables:** Ensure correct values per environment

### Code Quality Standards

#### TypeScript
- **Strict Mode:** Enabled in tsconfig.json
- **Type Safety:** Avoid `any` types, use proper interfaces
- **Component Props:** Define interfaces for all props
- **API Responses:** Type all API responses

#### ESLint & Prettier
- **Linting:** Code quality and consistency
- **Formatting:** Consistent code style
- **Import Order:** Organized imports
- **Unused Variables:** Remove unused code

### Integration with Backend

#### API Communication
- **Base URL:** Environment-aware API endpoints
- **Authentication:** Sanctum token management
- **Error Handling:** Graceful API failure handling
- **Loading States:** User feedback during API calls

#### Cross-Domain Considerations
- **CORS:** Backend configured for frontend domains
- **Authentication:** Sanctum handles cross-domain tokens
- **Webhooks:** Payment and confirmation flows
- **File Uploads:** Handle file uploads through backend API

This guide provides comprehensive instructions for Next.js frontend development on the Dadisi Community Labs platform. Focus on responsive design, accessibility, and PWA capabilities while maintaining clean, type-safe code.
