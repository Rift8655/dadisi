# Frontend Development - Copilot Instructions

## Next.js Frontend Development Guidelines

**Location:** This file provides specific guidance for frontend development in the `frontend/` directory.

**Framework:** Next.js 15+ with App Router, React 18+, TypeScript
**Styling:** Tailwind CSS + shadcn/ui component library
**Deployment:** Vercel with global CDN and edge caching
**PWA:** Progressive Web App with offline capabilities

## Azure DevOps Frontend Integration

### Repository: dadisi_frontend
- **URL:** https://dev.azure.com/pascalmuchiri/dadisi_app/_git/dadisi_frontend
- **Branch Strategy:** GitHub Flow (main branch, feature branches)
- **Pipeline:** Separate frontend deployment pipeline to Vercel

### Frontend Work Items
**Common Frontend Work Item Types:**
- **Feature:** UI components, pages, user flows
- **User Story:** Frontend functionality (e.g., "As a member, I want to RSVP to events")
- **Bug:** UI issues, responsive design problems, PWA failures
- **Task:** Component refactoring, performance optimization, accessibility improvements

**Frontend-Specific Acceptance Criteria:**
- Responsive design works on mobile, tablet, desktop
- PWA installs and works offline
- API integration handles loading and error states
- Accessibility meets WCAG 2.1 AA standards
- Performance meets Core Web Vitals requirements

### Azure DevOps PowerShell Scripts
The project includes PowerShell scripts in the `Docs/` directory for managing Azure DevOps work items. These scripts integrate with the Azure CLI and can be used for bulk operations, state management, and hierarchy maintenance.

#### Available Scripts

1. **UpdateWorkItemState.ps1**
   - **Purpose:** Updates the state of one or more Azure DevOps work items
   - **Usage:** `.\UpdateWorkItemState.ps1 -WorkItemIds 123,124 -NewState "Active" -Comment "Ready for development"`
   - **Parameters:**
     - `WorkItemIds`: Array of work item IDs (required)
     - `NewState`: New state (New, Active, Resolved, Closed, etc.) (required)
     - `Comment`: Optional comment for the state change
     - `Project`: Azure DevOps project name (defaults to 'dadisi_app')
     - `Force`: Skip confirmation prompt
   - **Requirements:** Azure CLI with Azure DevOps extension

2. **CheckWorkItems.ps1**
   - **Purpose:** Displays detailed information about a specific work item including hierarchy
   - **Usage:** `.\CheckWorkItems.ps1 123`
   - **Output:** Work item details, parent-child relationships, and full hierarchy
   - **Requirements:** Azure CLI with Azure DevOps extension

3. **CheckAllWorkItems.ps1**
   - **Purpose:** Lists all work items in the Azure DevOps project
   - **Usage:** `.\CheckAllWorkItems.ps1`
   - **Output:** Summary of all work items with ID, title, type, and state
   - **Requirements:** Azure CLI with Azure DevOps extension

4. **create_ado_workitems_v2.ps1**
   - **Purpose:** Bulk creates work items from CSV files with duplicate prevention and parent-child linking
   - **Usage:** `.\create_ado_workitems_v2.ps1 -pat "your-pat-token"`
   - **Features:**
     - Processes CSV files from `Docs/workitems/` directory
     - Handles duplicates based on Key, Title, and Type
     - Establishes parent-child relationships in two passes
     - Logs all operations to `created_work_items_log.csv`
   - **CSV Format:** Requires columns like Key, Title, WorkItemType, Parent, Description, etc.
   - **Requirements:** Azure CLI, Personal Access Token (PAT) with work item permissions

5. **create_ado_workitems.ps1**
   - **Purpose:** Earlier version of bulk work item creation script
   - **Usage:** Similar to v2 but with slightly different duplicate handling
   - **Note:** Use v2 for new operations; this is maintained for reference

6. **AddParentLinkRelation.ps1**
   - **Purpose:** Establishes parent-child relationships between existing work items
   - **Usage:** `.\AddParentLinkRelation.ps1 -pat "your-pat-token"`
   - **Features:** Uses Azure DevOps REST API for reliable linking
   - **Requirements:** Azure CLI, Personal Access Token (PAT)

#### Script Integration with Development Workflow
- **Work Item Creation:** Use `create_ado_workitems_v2.ps1` for bulk importing work items from planning documents
- **State Management:** Use `UpdateWorkItemState.ps1` for transitioning work items through development stages
- **Hierarchy Management:** Use `AddParentLinkRelation.ps1` for establishing or fixing parent-child relationships
- **Monitoring:** Use `CheckWorkItems.ps1` and `CheckAllWorkItems.ps1` for tracking work item status and hierarchy

#### Requirements and Setup
- **Azure CLI:** Must be installed and authenticated (`az login`)
- **Azure DevOps Extension:** Install with `az extension add --name azure-devops`
- **Personal Access Token (PAT):** Required for scripts that modify work items
  - Create in Azure DevOps: User Settings → Personal Access Tokens
  - Scopes: Work Items (read, write, manage)
- **Project Configuration:** Scripts default to 'dadisi_app' project but can be parameterized

#### Troubleshooting Script Issues
- **Authentication Errors:** Verify PAT token and Azure CLI login status
- **Extension Issues:** Reinstall Azure DevOps extension if commands fail
- **Permission Errors:** Ensure PAT has appropriate scopes for work item operations
- **CSV Format Errors:** Validate CSV structure matches expected columns
- **Hierarchy Issues:** Use `CheckWorkItems.ps1` to verify parent-child relationships before linking

### MCP Server Integration
The project is configured with several Model Context Protocol (MCP) servers that provide additional tools and resources for development. These servers enhance Copilot's capabilities for specific tasks.

#### Available MCP Servers

1. **GitHub MCP Server (@github/github-mcp-server)**
   - **Purpose:** GitHub repository management, issues, pull requests, and code search
   - **Usage:** Use for GitHub-related operations like creating issues, reviewing PRs, or searching code across repositories
   - **Integration:** Automatically available for GitHub operations in the project

2. **Supabase MCP Server (supabase-mcp-server)**
   - **Purpose:** Supabase database operations, schema management, and query execution
   - **Usage:** Use for database-related tasks, migrations, or querying Supabase projects
   - **Integration:** Useful for backend database development and testing
   - **Note:** Configured with access token for authenticated operations

3. **Sentry MCP Server (getsentry/sentry-mcp)**
   - **Purpose:** Error tracking, monitoring, and performance analysis
   - **Usage:** Use for debugging, error investigation, and performance monitoring
   - **Integration:** Helpful for troubleshooting backend issues and monitoring production errors

4. **Context7 MCP Server (upstash/context7)**
   - **Purpose:** Documentation search, library information, and code examples
   - **Usage:** Use for looking up documentation, finding libraries, or getting code snippets
   - **Integration:** Useful for research and learning new technologies
   - **Note:** Requires context7_api_key for full functionality

5. **Sequential Thinking MCP Server (sequential-thinking)**
   - **Purpose:** Structured problem-solving and step-by-step reasoning
   - **Usage:** Use for complex problem analysis, planning, and decision-making processes
   - **Integration:** Helpful for breaking down complex features or debugging issues

6. **21st.dev Magic MCP Server (@21st-dev/magic)**
   - **Purpose:** UI component generation, design inspiration, and frontend development
   - **Usage:** Use for creating React components, getting design ideas, or improving UI
   - **Integration:** Particularly useful for frontend development tasks
   - **Commands:** Use /ui, /21, or /21st to trigger component generation

#### Using MCP Servers in Development
- **Automatic Integration:** MCP servers are automatically available based on context and can be triggered by relevant queries
- **Specific Triggers:**
  - For UI components: Mention /ui, /21, or /21st in your queries
  - For documentation: Use Context7 for library or framework research
  - For problem-solving: Invoke sequential thinking for complex analysis
  - For database tasks: Use Supabase MCP for schema or query operations
- **Best Practices:** Be specific in your requests to leverage the appropriate MCP server effectively

#### MCP Configuration
- **Location:** Configured in VS Code's MCP settings (`mcp.json`)
- **Management:** Servers can be enabled/disabled or reconfigured as needed
- **Updates:** Keep MCP servers updated for latest features and security

## Next.js Development Standards

### Project Structure
```
frontend/
├── src/
│   ├── app/                 # App Router pages and layouts
│   ├── components/          # Reusable React components
│   ├── lib/                 # Utility functions and configurations
│   ├── store/               # State management (custom hooks)
│   ├── types/               # TypeScript type definitions
│   └── styles/              # Global styles and Tailwind config
├── public/                  # Static assets
├── components.json          # shadcn/ui configuration
└── tailwind.config.js       # Tailwind CSS configuration
```

### App Router Structure
```
src/app/
├── layout.tsx              # Root layout with providers
├── page.tsx                # Home page
├── admin/                  # Admin pages
├── blog/                   # Blog pages
├── dashboard/              # User dashboard
├── donations/              # Donation pages
├── events/                 # Event pages
└── membership/             # Membership pages
```

### Component Architecture

#### shadcn/ui Components
- **Location:** `src/components/ui/` (button, card, input, etc.)
- **Customization:** Override default styles in component files
- **Usage:** Import from `@/components/ui/[component-name]`

#### Custom Components
- **Location:** `src/components/` (auth-dialog, events-client, etc.)
- **Naming:** PascalCase for components, kebab-case for files
- **Props:** TypeScript interfaces for all props
- **Styling:** Tailwind CSS classes with responsive design

#### Component Example
```tsx
// src/components/events-client.tsx
interface EventsClientProps {
  events: Event[];
  loading: boolean;
}

export function EventsClient({ events, loading }: EventsClientProps) {
  if (loading) return <div>Loading events...</div>;

  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {events.map((event) => (
        <Card key={event.id} className="hover:shadow-lg transition-shadow">
          {/* Event content */}
        </Card>
      ))}
    </div>
  );
}
```

### State Management

#### Custom Hooks
- **Location:** `src/store/` (useDonationStore, useRsvpStore, etc.)
- **Pattern:** Zustand for complex state, useState for local state
- **API Integration:** Handle loading, error, and success states

#### API Integration Pattern
```tsx
// src/store/useDonationStore.ts
interface DonationState {
  donations: Donation[];
  loading: boolean;
  error: string | null;
  fetchDonations: () => Promise<void>;
}

export const useDonationStore = create<DonationState>((set, get) => ({
  donations: [],
  loading: false,
  error: null,
  fetchDonations: async () => {
    set({ loading: true, error: null });
    try {
      const response = await fetch('/api/donations');
      const donations = await response.json();
      set({ donations, loading: false });
    } catch (error) {
      set({ error: 'Failed to fetch donations', loading: false });
    }
  },
}));
```

### Styling Guidelines

#### Tailwind CSS
- **Responsive Design:** Use `sm:`, `md:`, `lg:`, `xl:` prefixes
- **Component Variants:** Hover, focus, active states
- **Custom Colors:** Define in `tailwind.config.js`
- **Spacing:** Use consistent spacing scale

#### shadcn/ui Integration
```tsx
// Example component using shadcn/ui
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

export function EventCard({ event }: { event: Event }) {
  return (
    <Card className="w-full max-w-sm mx-auto">
      <CardHeader>
        <CardTitle>{event.title}</CardTitle>
      </CardHeader>
      <CardContent>
        <p className="text-muted-foreground">{event.description}</p>
        <Button className="w-full mt-4">RSVP Now</Button>
      </CardContent>
    </Card>
  );
}
```

### PWA Implementation

#### Service Worker
- **Caching Strategy:** Cache-first for static assets, network-first for API calls
- **Offline Fallback:** Custom offline page for core routes
- **Background Sync:** For form submissions when offline

#### Manifest Configuration
```json
// public/manifest.json
{
  "name": "Dadisi Community Labs",
  "short_name": "Dadisi",
  "description": "Community platform for events, donations, and memberships",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#000000",
  "icons": [...]
}
```

### API Integration

#### Environment Variables
```env
# Development (.env.local)
NEXT_PUBLIC_API_BASE_URL=http://localhost:8000/api
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Staging (.env.staging)
NEXT_PUBLIC_API_BASE_URL=https://staging-api.dadisilab.com/api
NEXT_PUBLIC_APP_URL=https://staging.dadisilab.com

# Production (.env.production)
NEXT_PUBLIC_API_BASE_URL=https://api.dadisilab.com/api
NEXT_PUBLIC_APP_URL=https://dadisilab.com
```

#### API Client Pattern
```tsx
// src/lib/api.ts
const API_BASE = process.env.NEXT_PUBLIC_API_BASE_URL;

export async function apiRequest(endpoint: string, options: RequestInit = {}) {
  const url = `${API_BASE}${endpoint}`;

  const response = await fetch(url, {
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${getAuthToken()}`,
      ...options.headers,
    },
    ...options,
  });

  if (!response.ok) {
    throw new Error(`API request failed: ${response.statusText}`);
  }

  return response.json();
}
```

#### Authentication Handling
```tsx
// src/lib/auth.ts
export function getAuthToken(): string | null {
  if (typeof window === 'undefined') return null;
  return localStorage.getItem('auth_token');
}

export function setAuthToken(token: string): void {
  if (typeof window === 'undefined') return;
  localStorage.setItem('auth_token', token);
}

export function clearAuthToken(): void {
  if (typeof window === 'undefined') return;
  localStorage.removeItem('auth_token');
}
```

### TypeScript Integration

#### Type Definitions
```tsx
// src/types/index.d.ts
export interface User {
  id: number;
  name: string;
  email: string;
  profile: MemberProfile;
}

export interface Event {
  id: number;
  title: string;
  description: string;
  starts_at: string;
  ends_at?: string;
  venue?: string;
  is_online: boolean;
  capacity?: number;
  county: County;
  price?: number;
  currency: string;
  status: 'draft' | 'published';
}

export interface County {
  id: number;
  name: string;
  code?: string;
}
```

#### API Response Types
```tsx
// src/types/api.ts
export interface ApiResponse<T> {
  data: T;
  meta?: {
    pagination?: {
      page: number;
      per_page: number;
      total: number;
      last_page: number;
    };
  };
}

export interface ApiError {
  message: string;
  errors?: Record<string, string[]>;
}
```

### Testing Standards

#### Component Testing
```tsx
// Example component test
import { render, screen } from '@testing-library/react';
import { EventCard } from '@/components/event-card';

describe('EventCard', () => {
  const mockEvent = {
    id: 1,
    title: 'Test Event',
    description: 'Test Description',
    starts_at: '2025-01-01T10:00:00Z',
    county: { id: 1, name: 'Nairobi' },
  };

  it('renders event information', () => {
    render(<EventCard event={mockEvent} />);
    expect(screen.getByText('Test Event')).toBeInTheDocument();
    expect(screen.getByText('Test Description')).toBeInTheDocument();
  });
});
```

#### E2E Testing
- **Tool:** Playwright or Cypress
- **Coverage:** Critical user flows (registration, donation, event RSVP)
- **CI Integration:** Run on pull requests

### Deployment to Vercel

#### Build Configuration
```json
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    domains: ['api.dadisilab.com', 'staging-api.dadisilab.com'],
  },
  async rewrites() {
    return [
      {
        source: '/api/:path*',
        destination: 'https://api.dadisilab.com/api/:path*',
      },
    ];
  },
};
```

#### Environment Variables in Vercel
- **Development:** Automatic from `.env.local`
- **Staging:** Set in Vercel dashboard for staging environment
- **Production:** Set in Vercel dashboard for production environment

#### PWA Optimization
- **Static Generation:** Use `generateStaticParams` for dynamic routes
- **Image Optimization:** Next.js Image component with proper sizing
- **Font Optimization:** Preload custom fonts
- **Bundle Analysis:** Monitor bundle size in production

### Performance Optimization

#### Core Web Vitals
- **LCP:** Optimize largest contentful paint with image optimization
- **FID:** Minimize JavaScript execution time
- **CLS:** Prevent layout shifts with proper sizing

#### Bundle Optimization
- **Code Splitting:** Dynamic imports for route-based splitting
- **Tree Shaking:** Remove unused code
- **Image Optimization:** Use Next.js Image component
- **Font Loading:** Optimize web font loading

### Accessibility (WCAG 2.1 AA)

#### Implementation Guidelines
- **Semantic HTML:** Use proper heading hierarchy, landmarks
- **Keyboard Navigation:** All interactive elements keyboard accessible
- **Screen Reader Support:** ARIA labels, descriptions
- **Color Contrast:** Minimum 4.5:1 contrast ratio
- **Focus Management:** Visible focus indicators

#### Testing Tools
- **Lighthouse:** Accessibility audit
- **axe-core:** Automated accessibility testing
- **Manual Testing:** Keyboard navigation, screen reader testing

### Responsive Design

#### Breakpoint Strategy
```css
/* Tailwind breakpoints */
sm: 640px   /* Small devices */
md: 768px   /* Medium devices */
lg: 1024px  /* Large devices */
xl: 1280px  /* Extra large devices */
```

#### Mobile-First Approach
- Base styles for mobile
- Progressive enhancement for larger screens
- Touch-friendly interface elements
- Optimized images for different screen densities

### Error Handling

#### API Error Handling
```tsx
// src/components/error-boundary.tsx
'use client';

import { Component, ReactNode } from 'react';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback: ReactNode;
}

export class ErrorBoundary extends Component<ErrorBoundaryProps> {
  state = { hasError: false };

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback;
    }
    return this.props.children;
  }
}
```

#### Loading States
```tsx
// src/components/loading-spinner.tsx
export function LoadingSpinner() {
  return (
    <div className="flex items-center justify-center p-8">
      <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
    </div>
  );
}
```

### Development Workflow

#### Creating New Features
1. **Work Item:** Create in Azure DevOps with UI/UX requirements
2. **Branch:** Create feature branch (`feature/123-user-dashboard`)
3. **Design:** Create responsive components with shadcn/ui
4. **Implementation:** Connect to backend APIs with proper error handling
5. **Testing:** Component tests and accessibility testing
6. **PWA Testing:** Verify offline functionality and installability
7. **Pull Request:** Submit with screenshots and testing notes
8. **Deployment:** Deploy via frontend pipeline to Vercel

#### Component Development
1. **Requirements:** Review acceptance criteria from work item
2. **Design:** Follow shadcn/ui patterns and Tailwind conventions
3. **Implementation:** TypeScript with proper prop types
4. **Responsive:** Test on multiple screen sizes
5. **Accessibility:** WCAG 2.1 AA compliance
6. **Performance:** Optimize images and loading states

### Vercel Deployment

#### Automatic Deployments
- **Trigger:** Pushes to main branch
- **Build Logs:** Available in Vercel dashboard
- **Environment Variables:** Configured per environment
- **Domain Management:** Custom domains with SSL

#### Deployment Checklist
- [ ] Environment variables configured
- [ ] Build passes without errors
- [ ] PWA manifest valid
- [ ] Service worker registered
- [ ] API endpoints accessible
- [ ] SSL certificate active

### Troubleshooting

#### Common Frontend Issues
- **Build Errors:** Check TypeScript errors, missing dependencies
- **Runtime Errors:** Check browser console, API connectivity
- **Styling Issues:** Verify Tailwind configuration, component imports
- **PWA Issues:** Check manifest, service worker registration
- **Performance Issues:** Monitor Core Web Vitals, bundle size

#### Vercel-Specific Issues
- **Deployment Failures:** Check build logs, environment variables
- **Domain Issues:** Verify DNS configuration, SSL certificates
- **Environment Variables:** Ensure correct values per environment

### Code Quality Standards

#### TypeScript
- **Strict Mode:** Enabled in tsconfig.json
- **Type Safety:** Avoid `any` types, use proper interfaces
- **Component Props:** Define interfaces for all props
- **API Responses:** Type all API responses

#### ESLint & Prettier
- **Linting:** Code quality and consistency
- **Formatting:** Consistent code style
- **Import Order:** Organized imports
- **Unused Variables:** Remove unused code

### Integration with Backend

#### API Communication
- **Base URL:** Environment-aware API endpoints
- **Authentication:** Sanctum token management
- **Error Handling:** Graceful API failure handling
- **Loading States:** User feedback during API calls

#### Cross-Domain Considerations
- **CORS:** Backend configured for frontend domains
- **Authentication:** Sanctum handles cross-domain tokens
- **Webhooks:** Payment and confirmation flows
- **File Uploads:** Handle file uploads through backend API

This guide provides comprehensive instructions for Next.js frontend development on the Dadisi Community Labs platform. Focus on responsive design, accessibility, and PWA capabilities while maintaining clean, type-safe code.
